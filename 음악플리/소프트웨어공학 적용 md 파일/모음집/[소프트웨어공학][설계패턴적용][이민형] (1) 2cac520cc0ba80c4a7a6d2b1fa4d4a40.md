# [소프트웨어공학][설계패턴적용][이민형] (1)

## **1. 클래스 다이어그램의 모든 클래스에 대한 의미와 기능 정리**

본 프로젝트는 음악 플랫폼 간 재생목록을 자동으로 이전하는 웹 기반 시스템으로, 시스템 분석 단계에서 기능 요구사항(FR), 비기능 요구사항(NFR), 인터페이스 요구사항(IF)을 토대로 초기 클래스 다이어그램을 구성하였다. 해당 클래스 다이어그램은  요구사항 분석 결과 도출된 구조를 기반으로 작성되었다. 따라서 본 절에서는 패턴 적용 전의 클래스들이 어떤 역할과 책임을 갖고 있었는지를 정리함으로써, 이후 단계에서 설계패턴을 적용할 수 있는 근거를 확인하였다.

우선 **AuthManager**는 Google OAuth 기반 인증 절차를 처리하며, 액세스 토큰 및 리프레시 토큰의 발급과 검증을 담당한다. **GenieParser**는 지니뮤직에서 제공하는 재생목록 페이지의 HTML 구조를 파싱하여 곡명과 아티스트 정보를 추출하는 역할을 수행하고, **YouTubeAPIClient**는 YouTube Data API를 통해 재생목록 생성 및 곡 추가 작업을 담당한다. 또한 **MatchingEngine**은 지니뮤직에서 추출된 곡 데이터와 YouTube 검색 결과 간의 유사도를 판별하는 기능을 가지고 있으며, **PlaylistConverter**는 전체 변환 흐름을 조정하여 파싱 → 매칭 → 업로드 과정을 순차적으로 수행하는 시스템의 중심에서 조정하는 역할을 한다.

변환 기록 관리는 **UserHistoryRepository**가 담당하며, 변환 성공 여부, 오류 발생 지점, API 요청 로그 등을 저장하여 사용자가 이전 변환 기록을 조회할 수 있도록 한다. 마지막으로 **Logger**는 시스템 전반에서 발생하는 오류나 이벤트를 기록하여 디버깅 및 유지보수 과정에서 필요한 정보를 제공한다.

이와 같이 초기 클래스 다이어그램은 기능 단위로 분리하여 구성되었지만, 플랫폼 확장성이나 모듈 간 결합도 측면에서 개선할 수 있는 부분들이 존재한다. 특히 플랫폼별 파서 생성, 외부 API 규격 차이, 다양한 매칭 알고리즘 적용 등의 요구가 증가함에 따라, 패턴을 적용하지 않은 기존 구조는 변경에 취약한 부분이 발견된다. 따라서 2~5번 단계에서 이 클래스들을 기반으로 설계패턴 적용 가능성을 식별하고, 구조적 완성도를 높이기 위해 적절한 패턴을 도입하는 설계 개선이 필요하다.

## **2. 생성 패턴 적용 가능성 평가 및 적용**

프로젝트는 지니뮤직 → 유튜브, 유튜브 → 스포티파이로 확장되며 다양한 입력 파싱 로직이 필요하다. 플랫폼에 따라 HTML 구조·API 구조·데이터 구조가 달라지는 특성상 객체 생성 로직을 코드 전반에 분산시키면 유지보수가 어려워진다.

이를 해결하기 위해 **Factory Method 패턴**을 적용하였다.

- **Creator**: ParserFactory
- **Product**: PlaylistParser (인터페이스)
- **ConcreteProduct**: GenieParser, YouTubePlaylistReader 등

**PlaylistConverter**는 단순히 플랫폼 타입만 전달하면 `ParserFactory.createParser()`를 통해 적절한 파서 객체를 반환받는다.

이로써 신규 플랫폼(예: 멜론, FLO, Vibe)이 추가되더라도 기존 변환 로직은 수정되지 않고, 새로운 Parser 클래스만 추가하면 되므로 높은 확장성을 확보할 수 있다.

![image.png](%5B%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99%5D%5B%EC%84%A4%EA%B3%84%ED%8C%A8%ED%84%B4%EC%A0%81%EC%9A%A9%5D%5B%EC%9D%B4%EB%AF%BC%ED%98%95%5D%20(1)/image.png)

## **3. 구조 패턴 적용 가능성 평가 및 적용**

외부 플랫폼 API의 구조는 서비스마다 크게 다르다.

예:

- YouTube → playlistItems.insert
- Spotify → /tracks endpoint 기반 검색 후 playlist replaceItems 구조
- Apple Music → MusicKit 기반 토큰 인증

이러한 차이에도 불구하고 시스템 내부에서는 “재생목록 생성”과 “곡 추가”라는 동일한 의미의 기능만 필요하다.

따라서 **Adapter 패턴**을 적용하여 다음의 구조를 설계했다.

- **Target 인터페이스**: IPlaylistTargetAPI
- **Adapter**: YouTubeAdapter, SpotifyAdapter
- **Adaptee**: YouTubeAPIClient, SpotifyAPIClient

이 방식은 외부 API의 구조적 차이를 내부 로직에서 완전히 감추기 때문에,

PlaylistConverter는 플랫폼 종류와 관계없이 하나의 통일된 방식으로 재생목록을 업로드할 수 있게 된다.

또한 Spotify 확장(유튜브 → 스포티파이 이전)을 시스템에 자연스럽게 통합할 수 있다.

![image.png](%5B%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99%5D%5B%EC%84%A4%EA%B3%84%ED%8C%A8%ED%84%B4%EC%A0%81%EC%9A%A9%5D%5B%EC%9D%B4%EB%AF%BC%ED%98%95%5D%20(1)/image%201.png)

## **4. 행위 패턴 적용 가능성 평가 및 적용**

매칭 알고리즘은 플랫폼 특성과 데이터 구조에 따라 지속적으로 변할 가능성이 높다.

특히 한글 기반 파싱(지니뮤직)과 영문 기반 파싱(유튜브/스포티파이)을 함께 지원하려면 다양한 매칭 전략을 유연하게 선택할 수 있어야 한다.

이 문제를 해결하기 위해 **Strategy 패턴**을 적용하였다.

- **Strategy 인터페이스**: MatchStrategy
- **Concrete Strategies**:
    - TitleExactMatch
    - FuzzyMatch (철자가 조금 달라도 얼마나 비슷한지 유사도 확인)
    - KoreanNormalizeMatch (자음과 모음 단위로 쪼개서 더 정확히 비교하는 방식)
- **Context**: MatchingEngine

MatchingEngine은 상황에 따라 적절한 전략을 선택하여 실행할 수 있으며,

새로운 매칭 방식이 필요할 때 기존 클래스를 수정할 필요 없이 새로운 Strategy만 추가하면 되므로 유지보수성과 확장성이 크게 향상된다.

![image.png](%5B%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99%5D%5B%EC%84%A4%EA%B3%84%ED%8C%A8%ED%84%B4%EC%A0%81%EC%9A%A9%5D%5B%EC%9D%B4%EB%AF%BC%ED%98%95%5D%20(1)/image%202.png)

## **5. 패턴 적용 후 변경된 클래스 다이어그램에 대해 Role-Playing**

![최종적으로  전체 설계패턴 적용된 클래스](%5B%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99%5D%5B%EC%84%A4%EA%B3%84%ED%8C%A8%ED%84%B4%EC%A0%81%EC%9A%A9%5D%5B%EC%9D%B4%EB%AF%BC%ED%98%95%5D%20(1)/image%203.png)

최종적으로  전체 설계패턴 적용된 클래스

위와 같은 패턴이 적용 된다면, 시스템 속 객체들은 다음과 같은 역할을 수행하게된다.

### Factory Method 패턴 Role-Playing

- **ParserFactory (Creator)**: 어떤 파서를 생성할지 결정
- **PlaylistParser (Product)**: 파서의 공통 인터페이스
- **GenieParser / YouTubePlaylistReader (ConcreteProduct)**: 실제 파싱 수행
- **PlaylistConverter (Client)**: Parser의 구체 클래스를 몰라도 되고, Factory의 결과만 사용

### Adapter 패턴 Role-Playing

- **IPlaylistTargetAPI (Target)**: 변환 과정에서 필요한 공통 작업 정의
- **YouTubeAdapter / SpotifyAdapter (Adapter)**: 플랫폼별 API 요청 형식을 공통 규격에 맞게 변환
- **YouTubeAPIClient / SpotifyAPIClient (Adaptee)**: 실제 외부 API 호출 수행
- **PlaylistConverter (Client)**: API 구조 차이를 몰라도 한 가지 방식으로 호출 가능

### Strategy 패턴 Role-Playing

- **MatchStrategy (Strategy)**: 매칭 알고리즘의 표준 인터페이스 제공
- **TitleExactMatch, FuzzyMatch, KoreanNormalizeMatch (ConcreteStrategy)**: 각기 다른 알고리즘 구현
- **MatchingEngine (Context)**: 상황에 적합한 전략 선택 후 실행

이를 통해 전체 설계는 입력 파싱 모듈의 확장성, 외부 API 구조 통합, 매칭 로직 다양화라는 핵심 세 요소를 안정적으로 만족하게 되었으며, 변경과 확장에 강한 구조로 바뀌었다.